#                                           CS 240, Lab #4
# 
#                                          IMPORTATNT NOTES:
# 
#                       Write your assembly code only in the marked blocks.
# 
#                       DO NOT change anything outside the marked blocks.
# 
#
j main
###############################################################################
#                           Data Section
.data

# 
# Fill in your name, student ID in the designated sections.
# 
student_name: .asciiz "Jaden Ong"
student_id: .asciiz "130829085"

new_line: .asciiz "\n"
space: .asciiz " "


t1_str: .asciiz "Testing GCD: \n"
t2_str: .asciiz "Testing LCM: \n"
t3_str: .asciiz "Testing RANDOM SUM: \n"

po_str: .asciiz "Obtained output: " 
eo_str: .asciiz "Expected output: "

#GCD_test_data_A:	.word 1, 2, 128, 148, 36, 360, 108, 75, 28300, 0
#GCD_test_data_B:	.word 12, 12, 96, 36, 54, 210, 144, 28300, 74000, 143

GCD_test_data_A:	.word 1, 36, 360, 108, 28300
GCD_test_data_B:	.word 12,54, 210, 144, 74000

GCD_output:           .word 1, 18, 30, 36, 100

#LCM_test_data_A:	.word 0, 1, 2, 128, 148, 36, 360, 108, 75, 28300
#LCM_test_data_B:	.word 143, 12, 12, 96, 36, 54, 210, 144, 28300, 74000
#LCM_output:           .word 0, 12, 12, 384, 1332, 108, 2520, 432, 84900, 20942000 


LCM_test_data_A:	.word 1, 36, 360, 108, 28300
LCM_test_data_B:	.word 12,54, 210, 144, 74000
LCM_output:           .word 12, 108, 2520, 432, 20942000

RANDOM_test_data_A:	.word 1, 144, 42, 260, 74000
RANDOM_test_data_B:	.word 12, 108,  54, 210, 44000
RANDOM_test_data_C:	.word 4, 109, 36, 360, 28300

RANDOM_output:           .word 26, 720, 216, 3120, 21044400

###############################################################################
#                           Text Section
.text
# Utility function to print an array
print_array:
li $t1, 0
move $t2, $a0
print:

lw $a0, ($t2)
li $v0, 1   
syscall

li $v0, 4
la $a0, space
syscall

addi $t2, $t2, 4
addi $t1, $t1, 1
blt $t1, $a1, print
jr $ra
###############################################################################
###############################################################################
#                           PART 1 (GCD)
#a0: input number
#a1: input number

#v0: final gcd answer

.globl gcd
gcd:
############################### Part 1: your code begins here ################
# gcd header already up here

# if (Y == 0){
# return X
# else 
# return gcd(y, x % y)

# a0 = x, a1 = y

bnez $a1, else # if y is not equal to 0, branch to else 
move $v0, $a0 # answer stored with the final X
jr $ra

else:
div $a0, $a1 # x / y
move $a0, $a1 # Y becomes the new X when recursively calling
mfhi $a1 # remainder is the new Y when recursively calling
j gcd # recursive call using these new parameters




############################### Part 1: your code ends here  ##################
jr $ra
###############################################################################
###############################################################################
#                           PART 2 (LCM)

# Find the least common multiplier of two numbers given
# Make a call to the GCD function to compute the LCM
# LCM = a1*a2 / GCD

# Preserve all required values in stack before calls to another function.
# preserve the $ra register value in stack before making the call!!!

#a0: input number
#a1: input number
#v0: final gcd answer

.globl lcm
lcm:
############################### Part 2: your code begins here ################

# (m*n) / GCD(m , n) ; do gcd(m,n) first, then (m * n), then that / gcd(m,n)


# calculate gcd(m,n) 
addi $sp, $sp, -4 # preserve return address w/ stack
sw $ra, 0($sp) 

addi $sp, $sp, -4 # preserve a0
sw $a0, 0 ($sp)  

addi $sp, $sp, -4 # preserve a1
sw $a1, 0($sp) 



jal gcd # call gcd subroutine using a0 & a1
# after the call, v0 will hold the gcd of m and n ( v0 = gcd(m, n))



lw $a1, 0 ($sp)  
addi $sp, $sp, 4 # deallocate a1

lw $a0, 0($sp) 
addi $sp, $sp, 4 # deallocate a0

lw $ra, 0($sp) # deallocate return address
addi $sp, $sp, 4

# multiply m and n

mult $a0, $a1 # m * n
mflo $t0 # move result into t0 temporarily


div $t0, $v0 # t0 (m * n) / v0 (result from gcd)
mflo $v0 # move final into v0




############################### Part 2: your code ends here  ##################
jr $ra
###############################################################################
#                           PART 3 (Random SUM)

# You are given three integers. You need to find the smallest 
# one and the largest one.
# 
# Then find the GCD and LCM of the two numbers. 
#
# Return the sum of Smallest, largest, GCD and LCM
#
# Implementation details:
# The three integers are stored in registers $a0, $a1, and $a2.
# Store the answer into register $v0. 
# Preserve all required values in stack before calls to another function.
# preserve the $ra register value in stack before making the call!!!
# Use stacks to store the smallest and largest values before making the function call. 

.globl random_sum
random_sum:
############################### Part 3: your code begins here ################

# find the largest and smallest of a0, a1, a2 - this code is from my lab 1 solution for find min and max

# find the largest of the three 
# a = a0 , b = a1, c = a2


blt $a1, $a0, AandC # if b < a, go to the check: AandC (c < a), if not we know b > a and must now check if b < c
blt $a1, $a2, cFinal # if b < c, we know that C is the largest, so go to cFinal, if not we know that B is the largest 
#B is the largest 
add $t4, $0, $a1 # STORE B IN LARGEST
# check if c < a to find smallest
blt $a2, $a0, cFinal2 # if c < a, c is smallest, if not a is smallest
j aFinal2
 
AandC:
blt $a2, $a0, aFinal # if c < a, this means that a is the largest, so go to aFinal, if not we know that C is the largest
j cFinal


aFinal:
add $t4, $0, $a0 # STORE A IN LARGEST
# check if b < c to find smallest
blt $a1, $a2, bFinal2 # if b < c, b is the smallest, if not c is the smallest
j cFinal2

cFinal: 
add $t4, $0, $a2 # STORE C IN LARGEST
# check if b < a to determine the smallest
blt $a0, $a1, aFinal2 # if a < b, a is the smallest, if not b is the smallest
j bFinal2


aFinal2:
add $t5, $0, $a0 # STORE A IN SMALLEST
j END

bFinal2:
add $t5, $0, $a1 # STORE B IN SMALLEST
j END

cFinal2:
add $t5, $0, $a2 # STORE C IN SMALLEST
j END

END:



# LCM =============================
move $a0, $t4 # save largest into a0 and smallest into a1
move $a1, $t5 

addi $sp, $sp, -4
sw $ra, 0($sp)

addi $sp, $sp, -4
sw $t4, 0($sp)

addi $sp, $sp, -4
sw $t5, 0($sp)

jal lcm

move $t8, $v0

lw $t5, 0($sp)
addi $sp, $sp, 4

lw $t4, 0($sp)
addi $sp, $sp, 4

lw $ra, 0($sp)
addi $sp, $sp, 4



# GCD =============================

move $a0, $t4 # save largest into a0 and smallest into a1
move $a1, $t5

addi $sp, $sp, -4
sw $ra, 0($sp)

addi $sp, $sp, -4
sw $t5, 0($sp)

addi $sp, $sp, -4
sw $t4, 0($sp)

addi $sp, $sp, -4 
sw $t8, 0($sp)

jal gcd

move $t9, $v0

lw $t8, 0($sp)
addi $sp, $sp, 4

lw $t4, 0($sp)
addi $sp, $sp, 4

lw $t5, 0($sp)
addi $sp, $sp, 4

lw $ra, 0($sp)
addi $sp, $sp, 4






# sum all 
add $v0, $0, $t9
add $v0, $v0, $t8
add $v0, $v0, $t4
add $v0, $v0, $t5






############################### Part 3: your code ends here  ##################
jr $ra
###############################################################################

#                          Main Function 
main:
li $v0, 4
la $a0, student_name
syscall
la $a0, new_line
syscall  
la $a0, student_id
syscall 
la $a0, new_line
syscall
la $a0, new_line
syscall
###############################################################################
#                          TESTING PART 1 - GCD
li $v0, 4
la $a0, new_line
syscall

li $v0, 4
la $a0, t1_str
syscall

li $v0, 4
la $a0, eo_str
syscall

li $v0, 4
la $a0, new_line
syscall

li $s0, 5 # num tests
la $s2, GCD_output
move $a0, $s2
move $a1, $s0
jal print_array

li $v0, 4
la $a0, new_line
syscall


li $v0, 4
la $a0, po_str
syscall

li $v0, 4
la $a0, new_line
syscall


#test_GCD:
li $s0, 5 # num tests
li $s1, 0
la $s2, GCD_test_data_A
la $s3, GCD_test_data_B
#j skip_line
##############################################
test_gcd:
#li $v0, 4
#la $a0, new_line
#syscall
#skip_line:
add $s4, $s2, $s1
add $s5, $s3, $s1
# Pass input parameter
lw $a0, 0($s4)
lw $a1, 0($s5)
jal gcd

move $a0, $v0
li $v0,1
syscall

li $v0, 4
la $a0, space
syscall

addi $s1, $s1, 4
addi $s0, $s0, -1
bgtz $s0, test_gcd

###############################################################################

#                          TESTING PART 2 - LCM
li $v0, 4
la $a0, new_line
syscall

li $v0, 4
la $a0, new_line
syscall

li $v0, 4
la $a0, t2_str
syscall

li $v0, 4
la $a0, eo_str
syscall

li $v0, 4
la $a0, new_line
syscall

li $s0, 5 # num tests
la $s2, LCM_output
move $a0, $s2
move $a1, $s0
jal print_array

li $v0, 4
la $a0, new_line
syscall


li $v0, 4
la $a0, po_str
syscall

li $v0, 4
la $a0, new_line
syscall


#test_GCD:
li $s0, 5 # num tests
li $s1, 0
la $s2, LCM_test_data_A
la $s3, LCM_test_data_B
#j skip_line
##############################################
test_lcm:
#li $v0, 4
#la $a0, new_line
#syscall
#skip_line:
add $s4, $s2, $s1
add $s5, $s3, $s1
# Pass input parameter
lw $a0, 0($s4)
lw $a1, 0($s5)
jal lcm

move $a0, $v0
li $v0,1
syscall

li $v0, 4
la $a0, space
syscall

addi $s1, $s1, 4
addi $s0, $s0, -1
bgtz $s0, test_lcm

###############################################################################
#                          TESTING PART 3 - RANDOM SUM
li $v0, 4
la $a0, new_line
syscall

li $v0, 4
la $a0, new_line
syscall

li $v0, 4
la $a0, t3_str
syscall

li $v0, 4
la $a0, eo_str
syscall

li $v0, 4
la $a0, new_line
syscall

li $s0, 5 # num tests
la $s2, RANDOM_output
move $a0, $s2
move $a1, $s0
jal print_array

li $v0, 4
la $a0, new_line
syscall


li $v0, 4
la $a0, po_str
syscall

li $v0, 4
la $a0, new_line
syscall


#test_GCD:
li $s0, 5 # num tests
li $s1, 0
la $s2, RANDOM_test_data_A
la $s3, RANDOM_test_data_B
la $s4, RANDOM_test_data_C
#j skip_line
##############################################
test_random:
#li $v0, 4
#la $a0, new_line
#syscall
#skip_line:
add $s5, $s2, $s1
add $s6, $s3, $s1
add $s7, $s4, $s1
# Pass input parameter
lw $a0, 0($s5)
lw $a1, 0($s6)
lw $a2, 0($s7)
jal random_sum

move $a0, $v0
li $v0,1
syscall

li $v0, 4
la $a0, space
syscall

addi $s1, $s1, 4
addi $s0, $s0, -1
bgtz $s0, test_random

###############################################################################

_end:

# new line
li $v0, 4
la $a0, new_line
syscall

# end program
li $v0, 10
syscall
###############################################################################
